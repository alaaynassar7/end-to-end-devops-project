name: $(Date:yyyyMMdd)$(Rev:.r)-Final-DevOps-Tools
trigger: none
pr: none

variables:
  # 1. Link Variable Group (Crucial for DATADOG_API_KEY and TF_DIR)
  - group: 'My Vars'

  # 2. Additional Variables
  - name: AWS_SERVICE_CONNECTION
    value: 'aws-alaa-2'
  
pool:
  name: 'Self hosted pools'
  demands:
    - Agent.Name -equals alaaynassar-VMware

steps:
- checkout: self
  persistCredentials: true

# 1. Install Basics
- task: TerraformInstaller@1
  displayName: Install Terraform
  inputs:
    terraformVersion: latest

- task: HelmInstaller@1
  displayName: Install Helm
  inputs:
    helmVersionToInstall: 'latest'

# 2. Configure AWS & Kubeconfig
- task: AWSShellScript@1
  displayName: 'Configure Cloud Access'
  inputs:
    awsCredentials: '$(AWS_SERVICE_CONNECTION)'
    regionName: '$(AWS_REGION)'
    scriptType: 'inline'
    inlineScript: |
      set -e
      
      # Install AWS CLI if missing
      if ! command -v aws &> /dev/null; then
          echo "Installing AWS CLI..."
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          sudo ./aws/install || ./aws/install -i ~/aws-cli -b ~/bin
          echo "##vso[task.prependpath]$HOME/bin"
      fi

      echo "Updating Kubeconfig for cluster: $(CLUSTER_NAME)..."
      aws eks update-kubeconfig --region $(AWS_REGION) --name $(CLUSTER_NAME)
      
      # Verify connection
      kubectl get svc

# 3. Export Terraform Outputs (Modules Support)
- task: AWSShellScript@1
  displayName: 'Export Infrastructure Outputs'
  inputs:
    awsCredentials: '$(AWS_SERVICE_CONNECTION)'
    regionName: '$(AWS_REGION)'
    scriptType: 'inline'
    inlineScript: |
      set -e
      # Use TF_DIR from Library
      echo "Navigating to Terraform Directory: $(TF_DIR)"
      cd $(TF_DIR)
      
      echo "Initializing Terraform to read outputs..."
      terraform init \
         -backend-config="bucket=$(S3_BUCKET_NAME)" \
         -backend-config="key=infra/nonprod/terraform.tfstate" \
         -backend-config="region=$(AWS_REGION)" \
         -reconfigure

      echo "Reading Outputs..."
      COGNITO_CLIENT_ID=$(terraform output -raw cognito_client_id)
      COGNITO_CLIENT_SECRET=$(terraform output -raw cognito_client_secret)
      COGNITO_ISSUER_URL=$(terraform output -raw cognito_issuer_url)
      APIGW_URL=$(terraform output -raw api_gateway_url)
      
      # Capture Cluster Name from Terraform for Datadog
      CLUSTER_NAME_TF=$(terraform output -raw cluster_name)

      # Set Pipeline Variables
      echo "##vso[task.setvariable variable=COGNITO_CLIENT_ID;isSecret=true]$COGNITO_CLIENT_ID"
      echo "##vso[task.setvariable variable=COGNITO_CLIENT_SECRET;isSecret=true]$COGNITO_CLIENT_SECRET"
      echo "##vso[task.setvariable variable=COGNITO_ISSUER_URL]$COGNITO_ISSUER_URL"
      echo "##vso[task.setvariable variable=APIGW_URL]$APIGW_URL"
      echo "##vso[task.setvariable variable=CLUSTER_NAME]$CLUSTER_NAME_TF"
      
      # Set Stable Cookie Secret
      echo "##vso[task.setvariable variable=COOKIE_SECRET;isSecret=true]STABLE_SECRET_V1_FOR_32_BYTE_AES"

# 4. Install Nginx Ingress (NLB)
- task: AWSShellScript@1
  displayName: 'Install Nginx Ingress (NLB)'
  inputs:
    awsCredentials: '$(AWS_SERVICE_CONNECTION)'
    regionName: '$(AWS_REGION)'
    scriptType: 'inline'
    inlineScript: |
      set -euo pipefail
      
      echo "Installing Nginx Ingress Controller..."
      helm upgrade --install ingress-nginx ingress-nginx \
        --repo https://kubernetes.github.io/ingress-nginx \
        --namespace ingress-nginx --create-namespace \
        --version 4.11.3 \
        --set controller.service.type=LoadBalancer \
        --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
        --set controller.admissionWebhooks.enabled=false \
        --wait --timeout 15m


# 6. Install OAuth2-Proxy
- task: AWSShellScript@1
  displayName: 'Install OAuth2-Proxy'
  inputs:
    awsCredentials: '$(AWS_SERVICE_CONNECTION)'
    regionName: '$(AWS_REGION)'
    scriptType: 'inline'
    inlineScript: |
      set -euo pipefail
      
      echo "Deploying OAuth2 Proxy..."
      helm uninstall oauth2-proxy -n ingress-nginx || true

      helm upgrade --install oauth2-proxy oauth2-proxy \
        --repo https://oauth2-proxy.github.io/manifests \
        --namespace ingress-nginx \
        --wait --atomic \
        --set config.clientID="$(COGNITO_CLIENT_ID)" \
        --set config.clientSecret="$(COGNITO_CLIENT_SECRET)" \
        --set config.cookieSecret="$(COOKIE_SECRET)" \
        --set extraArgs.provider="oidc" \
        --set extraArgs.oidc-issuer-url="$(COGNITO_ISSUER_URL)" \
        --set extraArgs.email-domain="gmail.com" \
        --set extraArgs.redirect-url="$(APIGW_URL)/oauth2/callback" \
        --set ingress.enabled=true \
        --set ingress.className="nginx" \
        --set ingress.path="/oauth2" \
        --set ingress.hosts[0]=""

# 7. Install Tools (Vault, Argo, Sonar)
- task: AWSShellScript@1
  displayName: 'Install DevOps Tools'
  inputs:
    awsCredentials: '$(AWS_SERVICE_CONNECTION)'
    regionName: '$(AWS_REGION)'
    scriptType: 'inline'
    inlineScript: |
      set -euo pipefail
      NS="alaa-tools"
      kubectl create namespace $NS --dry-run=client -o yaml | kubectl apply -f -

      # --- Vault ---
      echo "Installing Vault..."
      kubectl delete MutatingWebhookConfiguration vault-agent-injector-cfg --ignore-not-found=true
      
      helm upgrade --install vault vault \
        --repo https://helm.releases.hashicorp.com \
        --namespace $NS \
        --set "server.dev.enabled=true" \
        --set "ui.enabled=true" \
        --set "ui.service.type=ClusterIP" \
        --set "server.ingress.enabled=true" \
        --set "server.ingress.ingressClassName=nginx" \
        --set "server.ingress.hosts[0].host=" \
        --set "server.ingress.hosts[0].paths[0]=/vault"

      # --- ArgoCD ---
      echo "Installing ArgoCD..."
      helm upgrade --install argocd argo-cd \
        --repo https://argoproj.github.io/argo-helm \
        --namespace $NS \
        --set server.service.type=ClusterIP \
        --set server.ingress.enabled=true \
        --set server.ingress.ingressClassName=nginx \
        --set server.ingress.extraArgs={--insecure,--rootpath=/argocd} \
        --set server.ingress.paths[0]=/argocd

      # --- SonarQube ---
      echo "Installing SonarQube..."
      helm upgrade --install sonarqube sonarqube \
        --repo https://SonarSource.github.io/helm-chart-sonarqube \
        --namespace $NS \
        --set community.enabled=true \
        --set ingress.enabled=true \
        --set ingress.ingressClassName=nginx \
        --set ingress.hosts[0].name="" \
        --set ingress.hosts[0].path="/sonarqube" \
        --set sonarWebContext=/sonarqube \
        --wait --timeout 10m

# 8. Update Terraform & Dynamic Push (Smart Branching)
- task: AWSShellScript@1
  displayName: 'Link Load Balancer to Terraform'
  inputs:
    awsCredentials: '$(AWS_SERVICE_CONNECTION)'
    regionName: '$(AWS_REGION)'
    scriptType: 'inline'
    inlineScript: |
      set -e
      # Use TF_DIR from Library
      cd $(TF_DIR)

      echo "Fetching NLB DNS..."
      timeout=300
      end=$((SECONDS + timeout))
      while true; do
        LB_DNS=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "")
        if [ -n "$LB_DNS" ]; then
            echo "Found NLB: $LB_DNS"
            break
        fi
        if [ $SECONDS -ge $end ]; then echo "Timeout waiting for LB"; exit 1; fi
        sleep 10
      done

      echo "Updating nonprod.tfvars..."
      NEW_URI="http://$LB_DNS"
      
      if grep -q "integration_uri" nonprod.tfvars; then
        sed -i "s|integration_uri.*|integration_uri = \"$NEW_URI\"|g" nonprod.tfvars
      else
        echo "integration_uri = \"$NEW_URI\"" >> nonprod.tfvars
      fi

      echo "Applying Terraform Update..."
      terraform apply -var-file="nonprod.tfvars" -auto-approve

      # GitOps Push (To current branch dynamically)
      git config --global user.email "alaaynassar7@gmail.com"
      git config --global user.name "Alaa Nassar"
      git add nonprod.tfvars
      git commit -m "chore: update integration_uri with new NLB [skip ci]"
      # Pushing to the same branch running this pipeline
      git push origin HEAD:$(Build.SourceBranchName)